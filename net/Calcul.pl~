use strict;
use DDP;
use feature "switch";
no warnings 'experimental::smartmatch';

my %PRIORITY = (
    "("  => 5,
    ")"  => 5,
    "**" => 2,
    "^"  => 2,
    "*"  => 3,
    "/"  => 3,
    "+"  => 4,
    "-"  => 4
);
	
sub IsCorrectBrackets {
	my $expr = shift;
        $expr =~ s/[^()]//g;
        my $count = 0;
        for my $c (split //, $expr) { 
            if( $c eq '(' ) { $count++; }
            elsif( $c eq ')' ) { $count--; }        
            if ($count < 0) { return -1; }
       }
    $count == 0 ? 1 : 0;
}

sub ChangeExpr {
	my $expr = shift;	
	$expr =~ s/\*\*/^/g; #substitute potential
	$expr =~ s/([\+\-\*\/\^\(\)])/ $1 /g; #insert spaces around each operator
	$expr =~ s/^\s+|\s+$//g; #trim string
	$expr =~ s/ +/ /g;
	$expr =~ s/[eE]\s*(\+|\-)\s*/e$1/g;#substitute unary operation
	$expr =~ s/^([\+\-]) ([0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)/$1$2/g;
	$expr =~ s/(\(|\+|\-|\*|\/|\^) ([\+\-]) ([0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)/$1 $2$3/g;
	return $expr;
}

sub PolishNotation {
	my $brackets = IsCorrectBrackets(@_);
	#print "br  ", $brackets,"expr ", @_, $/;
	if ($brackets) {
		my @ops_stack;
   		my @output;
    		my @tokens = split(' ', ChangeExpr(@_));
		#p @tokens;
   		foreach my $token (@tokens) {
        		given ($token) {
            			when (/^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/) {
               				push @output, $token;
            			}
            			when ( ")" ) {
                			ProcessBracket(\@output, \@ops_stack);
            			}
            			when ( "(" ) {
            		   		 push @ops_stack, $token;
           			 }
            			default {
               				my $cur_priority = $PRIORITY{$token};
               				while ( @ops_stack and $PRIORITY{ $ops_stack[-1] } <= $cur_priority ) {
                    				if ( $token eq '^' and $PRIORITY{ $ops_stack[-1] } == $cur_priority ) {
                        				last;
                    				}
                  				push @output, pop @ops_stack;
               				}
               				push @ops_stack, $token;
            			}
       			}
		}
	while(@ops_stack){
		push @output, pop @ops_stack;
	}
	return @output;
	}
	else {
		return "error";
	}
}

sub ProcessBracket {
    my $output = $_[0];
    my $ops_stack = $_[1];
    my $head = pop @$ops_stack;
    while( $head ne "(" ) {
       push @$output, $head;
       $head = pop @$ops_stack;
    }
}

sub Counting {
	my $output = $_[0];
	my @result;
	foreach my $token (@$output) {
		my $c = $token;
		if ($token =~ /^[\+\*\^\/\-]$/) {
			my $r = pop @result;
			my $l = pop @result;
			given ($token) {
				when ("+") { $c = $l + $r;  }
				when ("-") { $c = $l - $r;  }
				when ("*") { $c = $l * $r;  }
				when ("/") { $c = $l / $r;  }
				when ("^") { $c = $l ** $r; }
			}
		}
		push @result, $c;
	}
	print "Result ",$result[0],$/;
	return $result[0];
}

sub GetPolishNotation {
	#p @_;
	return join(' ', PolishNotation(shift));
}

sub Calculation {
	my @polishnot = GetPolishNotation(shift);
	return Counting(\@polishnot);
}

while() {
    print "Insert your expression \n >> \n";
	my $expr = <STDIN>;
	my $type = 1;
    #my $expr = shift;
    given ($type) {
        when (1) { print Calculation($expr), $/; }
        when (2) { print IsCorrectBrackets($expr), $/; }
        when (3) { print GetPolishNotation($expr), $/; }
        default { return 'Unknown type'; }
    }
}

