use strict;
use warnings;
use v5.10.1;
use feature "switch";
use DDP;

my @exp=();#входное арифметическое выражение
my $outputstr = "";
my $op = "";
my @outstr = ();

sub GetExpression {
   
	my @operstack=();
	my @e=();
	my $priority = 0;
	my $prioritystack = 0;
	my $j=0;
	my $flag = 0;
	my $flag1 = 0;	
	my $flag2 = 0;	
	my $is_number = 0;
	my $expression = join('',@_);
	my $brackets = IsCorrectBrackets($expression);
	if($brackets) {
	$expression = PolishNotation($expression);
	@e = split("",$expression);
    	for (my $i = 0; $i <= $#e; $i++) {	
		#next if $e[$i] eq " ";
		$op = $e[$i];	
		print $op, $/;
        	if ($op =~ m/[0-9]{1}|\.{1}/s) {   
             		while (!($op eq " ")) {                
				# $flag = 1 if $op eq "e";
				 $outputstr = $outputstr.$e[$i]; 
                		 $i++;				 
				 $op = $e[$i];	
				print $op, $/;			 
				 #last if $flag;
                		 last if $i == $#e; 
            	    	}		 					 
			$outputstr = $outputstr.' ';					 
			$i--; 	              			 
			$op = $e[$i];	
			$is_number = 1;		 
        	} 
		#if($op eq "!") {				
		#	$outputstr = $outputstr.$op;			
		#}	
        	if ($op =~ m/[\+\-\/\^\*\!\(\)]/) {
            	if ($op eq "(") { 			
				push @operstack , $op;					
				$j=$#operstack;
			}
            	elsif ($op eq ")") {					
				$j=$#operstack;                
				while(!($operstack[$j] eq "(")) {				
					$outputstr = $outputstr.(pop @operstack);					
					$outputstr = $outputstr.' ';					
					$j--;				
				}				
				pop @operstack;				
				$j--;				
			}
			else {						
					$j=$#operstack;				
					if(@operstack) {						
						switch: {
							$prioritystack = 0,last switch if $operstack[$j] eq "(";		
							$prioritystack = 0,last switch if $operstack[$j] eq ")";
							$prioritystack = 1,last switch if $operstack[$j] eq "!";
							$prioritystack = 4,last switch if $operstack[$j] eq "^";
							#$prioritystack = 4,last switch if $operstack[$j] eq "**";
							$prioritystack = 3,last switch if $operstack[$j] eq "*";
							$prioritystack = 3,last switch if $operstack[$j] eq "/";
							$prioritystack = 2,last switch if $operstack[$j] eq "+";
							$prioritystack = 2,last switch if $operstack[$j] eq "-";
						}						
						switch: {
							$priority = 0,last switch if $op eq "(";			
							$priority = 0,last switch if $op eq ")";	
							$priority = 1,last switch if $op eq "!";
							$priority = 4,last switch if $op eq "^";
							#$priority = 4,last switch if $op eq "**";
							$priority = 3,last switch if $op eq "*";
							$priority = 3,last switch if $op eq "/";
							$priority = 2,last switch if $op eq "+";
							$priority = 2,last switch if $op eq "-";
						}
						if($priority <= $prioritystack) {						
							$outputstr = $outputstr.(pop @operstack);					
							$outputstr = $outputstr.' ';							
							#$outputstr = $outputstr."!",$flag2 = 0 if ($flag2);				
						}
					}					
					push @operstack, $op unless $op eq "!";		
				}		

        }		
        
    }		
		$j = $#operstack;	
		while(@operstack) {		
			$outputstr = $outputstr.(pop @operstack);		
			$outputstr = $outputstr.' ';	
			$j--;
		}	
	    return $outputstr; 
	}
	else {
		return "error";
	}
}

sub Counting {
	my $result = 0;	
	my @temp = ();
	my (@a_array, @b_array) = ( (), () );
	my ($astr, $bstr) = ("","");
	my $flaga = 0;
	my $flagb = 0;		
	
	for(my $i = 0; $i <= $#outstr; $i++) {	
		$op = $outstr[$i];		
		next if $op eq " ";
		if ($op =~ m/[0-9]{1}|\.{1}|\!{1}/s) { 			 
           		  while (!($op eq " ")) {                
				 $outputstr = $outputstr.$op;				 
                		 $i++;				 
				 $op = $outstr[$i];				 
               			 last if $i == $#outstr; 
			  }
			push @temp, $outputstr;			
			$outputstr = "";
	
		}
		elsif($op eq "+" or $op eq "-" or $op eq "*" or $op eq "/" or $op eq "^") {		
			@a_array = pop @temp;			
			@b_array = pop @temp;			
			if($i + 1 <= $#outstr && $op eq "*" && $outstr[($i + 1)] eq "*") {			
				$op = $op.$outstr[($i + 1)];				
				$i++;
				
			}
			for(my $j = 0; $j <= $#a_array; $j++) {				
				if($a_array[$j] =~ m/\!+/s ) {		
					$a_array[$j] =~ s/!//;				
					$flaga = 1;				
				}				
				$astr = $astr.$a_array[$j];			
			}			
			for(my $j = 0; $j <= $#b_array; $j++) {			
				if($b_array[$j] =~ m/\!+/s) {		
					$b_array[$j] =~ s/!//;					
					$flagb = 1;					
				}				
				$bstr = $bstr.$b_array[$j];		
				
			}
			$astr *= -1 if $flaga;
			$bstr *= -1 if $flagb;						
			$flaga = $flagb = 0;						
			switch: {							
							$result = $bstr ** $astr,last switch if $op eq "^";
							#$result = $bstr ** $astr,last switch if $op eq "**";
							$result = $bstr * $astr,last switch if $op eq "*";
							$result = $bstr / $astr,last switch if $op eq "/";
							$result = $bstr + $astr,last switch if $op eq "+";
							$result = $bstr - $astr,last switch if $op eq "-";
				}	
				push @temp, $result;
				$astr = "";
				$bstr = "";
		}
	}
	return pop @temp;
}

sub IsCorrectBrackets {
	my $expr = shift;
        $expr =~ s/[^()]//g;
        my $count = 0;
        for my $c (split //, $expr) { 
            if( $c eq '(' ) { $count++; }
            elsif( $c eq ')' ) { $count--; }        
            if ($count < 0) { return -1; }
       }
    $count == 0 ? 1 : 0;
}

sub PolishNotation {
my $expr = shift;
    #my @ops_stack;
   # my @output;
    #my $expr = "-16+(2)*0.3e+2-.5**(2-3)";
$expr =~ s/\*\*/^/g; #substitute potential
$expr =~ s/([\+\-\*\/\^\(\)])/ $1 /g; #insert spaces around each operator
$expr =~ s/^\s+|\s+$//g; #trim string
$expr =~ s/ +/ /g;
$expr =~ s/[eE]\s*(\+|\-)\s*/e$1/g; #deal with scientific notation
    #substitute unary op at the beginning
$expr =~ s/^([\-]) ([0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)/\!$2/g;
$expr =~ s/^([\+]) ([0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)/$1$2/g;
    #substitute unary op
$expr =~ s/(\(|\+|\-|\*|\/|\^) ([\-]) ([0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)/$1 \!$3/g;
$expr =~ s/(\(|\+|\-|\*|\/|\^) ([\+]) ([0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)/$1 $2$3/g;
    #print "Expression", $expr, $/;
#my @tokens = split(/ /, $expr);
#p @tokens;
#return \@tokens;
return $expr;
}

while() {
	my $res = 0;	
	my $res1 = 0;	
	print "Insert your expression \n >> \n";
	my $expression = <STDIN>;
	@exp=split //,$expression;
	$res = GetExpression(@exp);	
	if($res ne "error") {
	print "Polish notation\n";	
	@exp=();		
	$outputstr = $op = "";	
	my $str = "";
	$str .= $res;
	$res =~ s/!/-/g;
	print $res, $/;	
	@outstr = split //, $str;			
	$res1 = Counting();	
	$res1 =~ s/!/-/g;
	print "RESULT ".$res1."\n";
	}
	else {
		print "Uncorrect expression\n";
	}	
}

